<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>QR算法可视化</title>
<style>
body { font-family: 'Consolas', 'Monaco', monospace; margin: 0; background: #f5f5f5; }
.container { max-width: 1400px; margin: 0 auto; background: white; border-radius: 0 0 8px 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); }
.sticky-header { position: sticky; top: 0; z-index: 100; background: white; padding: 10px 20px; border-bottom: 1px solid #ddd; box-shadow: 0 2px 6px rgba(0,0,0,0.08); }
h1 { text-align: center; color: #333; margin: 5px 0; font-size: 20px; }
.controls { margin: 8px 0; display: flex; gap: 8px; flex-wrap: wrap; align-items: center; }
button { padding: 6px 14px; cursor: pointer; border: none; border-radius: 4px; background: #4CAF50; color: white; font-size: 13px; }
button:hover { background: #45a049; }
button:disabled { background: #ccc; cursor: not-allowed; }
button.btn-start { background: #2196F3; }
button.btn-start:hover { background: #1976D2; }
button.btn-start:disabled { background: #ccc; }
.input-section { margin: 8px 0; border: 1px solid #ddd; border-radius: 4px; overflow: hidden; }
.input-header { padding: 8px 10px; background: #f0f0f0; cursor: pointer; display: flex; justify-content: space-between; align-items: center; font-size: 13px; }
.input-header:hover { background: #e8e8e8; }
.input-content { padding: 15px; display: block; }
.input-content.collapsed { display: none; }
.matrix-input { display: grid; gap: 4px; margin: 10px 0; }
.matrix-input input { width: 60px; padding: 4px; text-align: center; border: 1px solid #ddd; border-radius: 3px; }
.content-area { padding: 10px 20px 20px; }
.matrix-display { display: inline-block; margin: 10px auto; position: relative; max-width: 100%; overflow-x: auto; overflow-y: hidden; }
.matrix-grid { display: grid; position: relative; }
.cell { display: flex; align-items: center; justify-content: center; font-weight: 600; position: relative; }
.cell.highlight-row { background: rgba(255, 152, 0, 0.3) !important; }
.cell.highlight-col { background: rgba(33, 150, 243, 0.3) !important; }
.region-box { position: absolute; pointer-events: none; box-sizing: border-box; }
.region-active { border: 5px solid #4CAF50; }
.region-active-double { border: 5px double #4CAF50; }
.region-shift-real { border: 4px dashed #ff6b6b; }
.region-shift-complex { border: 4px dashed #4dabf7; }
.info-panel { margin: 6px 0; padding: 8px 12px; background: #e3f2fd; border-radius: 4px; font-size: 13px; }
.info-row { display: flex; gap: 20px; margin-bottom: 4px; }
.info-row > div { white-space: nowrap; }
.progress { display: flex; align-items: center; gap: 8px; white-space: nowrap; }
.progress-bar { width: 1000px; max-width: 60vw; height: 16px; background: #e0e0e0; border-radius: 8px; overflow: hidden; cursor: pointer; flex-shrink: 0; }
.progress-fill { height: 100%; background: #4CAF50; transition: width 0.3s; }
kbd { display: inline-block; padding: 1px 5px; font-size: 11px; background: #f4f4f4; border: 1px solid #ccc; border-radius: 3px; font-family: inherit; }
.speed-control { display: flex; align-items: center; gap: 10px; }
input[type="range"] { width: 150px; }
input[type="number"] { width: 60px; padding: 4px; }
.error { color: red; margin: 10px 0; }
@media (max-width: 600px) {
  .sticky-header { padding: 6px 10px; }
  h1 { font-size: 16px; }
  .controls { gap: 5px; }
  button { padding: 5px 8px; font-size: 11px; }
  .speed-control { gap: 5px; }
  .speed-control label { font-size: 11px; }
  input[type="range"] { width: 80px; }
  .info-panel { padding: 6px 8px; font-size: 11px; }
  .info-row { gap: 10px; }
  .progress-bar { max-width: 40vw; }
  .content-area { padding: 6px 10px 10px; }
  .matrix-input input { width: 42px; font-size: 11px; padding: 3px; }
  .matrix-input { gap: 2px; }
  kbd { display: none; }
  .controls > span { display: none; }
}
</style>
</head>
<body>
<div class="container">

<div class="sticky-header">
<h1>QR算法可视化</h1>
<div class="controls">
<button id="startBtn" class="btn-start" onclick="startAlgorithm()" title="快捷键: Enter">开始算法</button>
<button id="prevBtn" onclick="prevStep()" disabled title="快捷键: ←">← 上一步</button>
<button id="stepBtn" onclick="nextStep()" disabled title="快捷键: →">下一步 →</button>
<button id="playBtn" onclick="togglePlay()" disabled title="快捷键: Space">▶ 播放</button>
<button id="resetBtn" onclick="reset()" title="快捷键: R">重置</button>
<div class="speed-control">
<label>速度:</label>
<input type="range" id="speedSlider" min="100" max="2000" value="500" step="100">
<span id="speedLabel">500ms</span>
</div>
<div class="speed-control">
<label>步长:</label>
<select id="stepSize">
<option value="1">小步(每个操作)</option>
<option value="2" selected>中步(完整变换)</option>
<option value="phase">大步(阶段)</option>
</select>
</div>
<span style="font-size:11px;color:#999;margin-left:auto;">
<kbd>Enter</kbd> 开始 <kbd>←</kbd><kbd>→</kbd> 步进 <kbd>Space</kbd> 播放 <kbd>R</kbd> 重置
</span>
</div>
<div class="info-panel">
<div class="info-row">
<div><strong>阶段:</strong> <span id="currentPhase">未开始</span></div>
<div><strong>操作:</strong> <span id="currentOp">-</span></div>
</div>
<div class="progress">
<strong>进度:</strong> <span id="stepCounter" style="min-width:60px">0 / 0</span>
<div class="progress-bar" onclick="jumpToProgress(event)"><div class="progress-fill" id="progressFill" style="width: 0%"></div></div>
</div>
</div>
</div>

<div class="content-area">
<div class="input-section">
<div class="input-header" onclick="toggleInput()">
<span><strong>矩阵输入</strong> (点击展开/收起)</span>
<span id="inputToggle">▼</span>
</div>
<div class="input-content" id="inputContent">
<label>矩阵大小: <input type="number" id="matrixSize" min="2" max="10" value="7"></label>
<button onclick="updateMatrixSize()">调整大小</button>
<button onclick="randomMatrix()">随机生成</button>
<button onclick="randomDiagonal()">随机对角</button>
<button onclick="randomSubdiagonal()">随机次对角</button>
<button onclick="randomSuperdiagonal()">随机超对角</button>
<button onclick="randomHessenberg()">随机Hessenberg</button>
<button onclick="clearMatrix()">清零</button>
<div id="matrixInputContainer"></div>
<div class="error" id="errorMsg"></div>
</div>
</div>

<div style="text-align: center;">
<div class="matrix-display" id="matrixDisplay"></div>
</div>
</div>

</div>

<script>
let n = 7;
let matrix = [];
let originalMatrix = [];
let steps = [];
let currentStep = 0;
let isPlaying = false;
let playInterval = null;
let colorMap = null;
let eigenvalues = [];
let globalIterCount = 0;

const epsilon = 1e-10;

function restartPlayIfNeeded() {
  if (isPlaying) {
    clearInterval(playInterval);
    const speed = parseInt(document.getElementById('speedSlider').value);
    playInterval = setInterval(() => {
      if (currentStep >= steps.length) { togglePlay(); } else { nextStep(); }
    }, speed);
  }
}

document.getElementById('speedSlider').addEventListener('input', (e) => {
  document.getElementById('speedLabel').textContent = e.target.value + 'ms';
  restartPlayIfNeeded();
});

const stepSpeedDefaults = { '1': 200, '2': 500, 'phase': 1000 };
document.getElementById('stepSize').addEventListener('change', (e) => {
  const speed = stepSpeedDefaults[e.target.value] || 500;
  document.getElementById('speedSlider').value = speed;
  document.getElementById('speedLabel').textContent = speed + 'ms';
  restartPlayIfNeeded();
});

document.addEventListener('keydown', (e) => {
  if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT' || e.target.tagName === 'TEXTAREA') return;
  switch (e.key) {
    case 'ArrowRight':
      e.preventDefault();
      if (!document.getElementById('stepBtn').disabled) nextStep();
      break;
    case 'ArrowLeft':
      e.preventDefault();
      if (!document.getElementById('prevBtn').disabled) prevStep();
      break;
    case ' ':
      e.preventDefault();
      if (!document.getElementById('playBtn').disabled) togglePlay();
      break;
    case 'Enter':
      e.preventDefault();
      if (!document.getElementById('startBtn').disabled) startAlgorithm();
      break;
    case 'r': case 'R':
      e.preventDefault();
      reset();
      break;
  }
});

function toggleInput() {
  const content = document.getElementById('inputContent');
  const toggle = document.getElementById('inputToggle');
  content.classList.toggle('collapsed');
  toggle.textContent = content.classList.contains('collapsed') ? '▶' : '▼';
}

function updateMatrixSize() {
  n = parseInt(document.getElementById('matrixSize').value);
  if (n < 2 || n > 10) {
    showError('矩阵大小必须在2到10之间');
    return;
  }
  createMatrixInput();
  showError('');
}

function createMatrixInput(fillRandom = true) {
  const container = document.getElementById('matrixInputContainer');
  container.innerHTML = '<h3>输入矩阵元素:</h3>';
  const grid = document.createElement('div');
  grid.className = 'matrix-input';
  const inputW = window.innerWidth < 600 ? 'repeat(' + n + ', 46px)' : 'repeat(' + n + ', 65px)';
  grid.style.gridTemplateColumns = inputW;

  for (let i = 0; i < n; i++) {
    for (let j = 0; j < n; j++) {
      const input = document.createElement('input');
      input.type = 'text';
      input.id = `input_${i}_${j}`;
      input.value = fillRandom ? (Math.random() * 20 - 10).toFixed(2) : '0';
      grid.appendChild(input);
    }
  }
  container.appendChild(grid);
}

function randomMatrix() {
  for (let i = 0; i < n; i++) {
    for (let j = 0; j < n; j++) {
      document.getElementById(`input_${i}_${j}`).value = (Math.random() * 20 - 10).toFixed(2);
    }
  }
}

function randomDiagonal() {
  for (let i = 0; i < n; i++) {
    document.getElementById(`input_${i}_${i}`).value = (Math.random() * 20 - 10).toFixed(2);
  }
}

function randomSubdiagonal() {
  for (let i = 1; i < n; i++) {
    document.getElementById(`input_${i}_${i-1}`).value = (Math.random() * 20 - 10).toFixed(2);
  }
}

function randomSuperdiagonal() {
  for (let i = 0; i < n - 1; i++) {
    document.getElementById(`input_${i}_${i+1}`).value = (Math.random() * 20 - 10).toFixed(2);
  }
}

function randomHessenberg() {
  for (let i = 0; i < n; i++) {
    for (let j = 0; j < n; j++) {
      const el = document.getElementById(`input_${i}_${j}`);
      el.value = (i <= j + 1) ? (Math.random() * 20 - 10).toFixed(2) : '0';
    }
  }
}

function clearMatrix() {
  for (let i = 0; i < n; i++) {
    for (let j = 0; j < n; j++) {
      document.getElementById(`input_${i}_${j}`).value = '0';
    }
  }
}

function showError(msg) {
  document.getElementById('errorMsg').textContent = msg;
}

function readMatrixInput() {
  const mat = [];
  for (let i = 0; i < n; i++) {
    mat[i] = [];
    for (let j = 0; j < n; j++) {
      const val = document.getElementById(`input_${i}_${j}`).value.trim();
      if (val === '' || isNaN(val)) {
        showError(`元素 (${i+1},${j+1}) 必须是数字`);
        return null;
      }
      mat[i][j] = parseFloat(val);
    }
  }
  return mat;
}

function copyMatrix(mat) {
  return mat.map(row => [...row]);
}

function createColorMap(mat) {
  let maxAbs = 0;
  for (let i = 0; i < mat.length; i++) {
    for (let j = 0; j < mat[i].length; j++) {
      maxAbs = Math.max(maxAbs, Math.abs(mat[i][j]));
    }
  }
  return { maxAbs };
}

function getColor(val, colorMap) {
  if (Math.abs(val) < epsilon) return '#bbb';
  const ratio = Math.min(Math.abs(val) / colorMap.maxAbs, 1);
  const h = (1 - ratio) * 270;
  return `hsl(${h}, 80%, 45%)`;
}

function calcCellSize(cols) {
  const container = document.querySelector('.content-area');
  const maxW = (container ? container.clientWidth : window.innerWidth) - 20;
  const idealGap = 10, idealPad = 25, idealCell = 65;
  const needed = cols * idealCell + (cols - 1) * idealGap + 2 * idealPad;
  if (needed <= maxW) return { cellSize: idealCell, gap: idealGap, padding: idealPad };
  const minGap = 3, minPad = 8;
  const avail = maxW - 2 * minPad - (cols - 1) * minGap;
  const cell = Math.max(Math.floor(avail / cols), 20);
  const gap = Math.max(Math.min(Math.floor(cell * 0.15), idealGap), minGap);
  const pad = Math.max(Math.min(Math.floor(cell * 0.35), idealPad), minPad);
  return { cellSize: cell, gap, padding: pad };
}

function displayMatrix(mat, highlightRows = [], highlightCols = [], activeRegion = null, shiftBox = null) {
  const display = document.getElementById('matrixDisplay');
  const { cellSize, gap, padding } = calcCellSize(mat[0].length);
  const fontSize = Math.max(Math.round(cellSize * 0.23), 9);

  const wrapper = document.createElement('div');
  wrapper.style.position = 'relative';
  wrapper.style.display = 'inline-block';

  const grid = document.createElement('div');
  grid.className = 'matrix-grid';
  grid.style.gridTemplateColumns = `repeat(${mat[0].length}, ${cellSize}px)`;
  grid.style.gap = gap + 'px';
  grid.style.padding = padding + 'px';

  for (let i = 0; i < mat.length; i++) {
    for (let j = 0; j < mat[i].length; j++) {
      const cell = document.createElement('div');
      cell.className = 'cell';
      cell.style.width = cellSize + 'px';
      cell.style.height = cellSize + 'px';
      cell.style.fontSize = fontSize + 'px';
      const val = Math.abs(mat[i][j]) < epsilon ? 0 : mat[i][j];
      cell.textContent = val === 0 ? '0' : val.toFixed(2);
      cell.style.color = getColor(mat[i][j], colorMap);

      const inActiveRegion = !activeRegion || (i >= activeRegion.start && i <= activeRegion.end && j >= activeRegion.start && j <= activeRegion.end);
      if (inActiveRegion) {
        if (highlightRows.includes(i)) cell.classList.add('highlight-row');
        if (highlightCols.includes(j)) cell.classList.add('highlight-col');
      }

      grid.appendChild(cell);
    }
  }

  wrapper.appendChild(grid);

  if (activeRegion) {
    const box = document.createElement('div');
    const activeClass = activeRegion.shiftType === 'double' ? 'region-active-double' : 'region-active';
    box.className = 'region-box ' + activeClass;
    box.style.left = (padding + activeRegion.start * (cellSize + gap) - 5) + 'px';
    box.style.top = (padding + activeRegion.start * (cellSize + gap) - 5) + 'px';
    box.style.width = ((activeRegion.end - activeRegion.start + 1) * cellSize + (activeRegion.end - activeRegion.start) * gap + 10) + 'px';
    box.style.height = ((activeRegion.end - activeRegion.start + 1) * cellSize + (activeRegion.end - activeRegion.start) * gap + 10) + 'px';
    wrapper.appendChild(box);
  }

  if (shiftBox) {
    const box = document.createElement('div');
    box.className = 'region-box ' + (shiftBox.isReal ? 'region-shift-real' : 'region-shift-complex');
    box.style.left = (padding + shiftBox.start * (cellSize + gap) - 3) + 'px';
    box.style.top = (padding + shiftBox.start * (cellSize + gap) - 3) + 'px';
    box.style.width = (2 * cellSize + gap + 6) + 'px';
    box.style.height = (2 * cellSize + gap + 6) + 'px';
    wrapper.appendChild(box);
  }

  display.replaceChildren(wrapper);
}

function startAlgorithm() {
  matrix = readMatrixInput();
  if (!matrix) return;

  originalMatrix = copyMatrix(matrix);
  colorMap = createColorMap(matrix);
  steps = [];
  currentStep = 0;
  eigenvalues = [];
  globalIterCount = 0;

  generateSteps();

  let maxAbs = colorMap.maxAbs;
  for (const step of steps) {
    if (!step.mat) continue;
    for (let i = 0; i < step.mat.length; i++)
      for (let j = 0; j < step.mat[i].length; j++)
        maxAbs = Math.max(maxAbs, Math.abs(step.mat[i][j]));
  }
  colorMap = { maxAbs };

  document.getElementById('startBtn').disabled = true;
  document.getElementById('stepBtn').disabled = false;
  document.getElementById('playBtn').disabled = false;
  document.getElementById('stepCounter').textContent = `0 / ${steps.length}`;
  updateProgress();
  displayCurrentStep();

  const content = document.getElementById('inputContent');
  if (!content.classList.contains('collapsed')) toggleInput();
}

function generateSteps() {
  if (n === 1) {
    steps.push({ type: 'direct', mat: copyMatrix(matrix), desc: '1×1矩阵, 直接读取特征值' });
    eigenvalues.push(matrix[0][0]);
    return;
  }

  if (!isHessenberg(matrix)) {
    toHessenberg();
  }
  qrIterations(0, n - 1, 0);
}

function isHessenberg(mat) {
  for (let i = 2; i < mat.length; i++) {
    for (let j = 0; j < i - 1; j++) {
      if (Math.abs(mat[i][j]) > epsilon) return false;
    }
  }
  return true;
}

function toHessenberg() {
  steps.push({ type: 'phase', phase: 'Hessenberg化', mat: copyMatrix(matrix), desc: '开始Hessenberg化' });

  for (let k = 0; k < n - 2; k++) {
    const rows = [];
    for (let i = k + 1; i < n; i++) rows.push(i);
    steps.push({ type: 'highlight_rows', rows, mat: copyMatrix(matrix), desc: `Householder变换消去第${k+1}列` });

    householderLeft(k);
    steps.push({ type: 'update', mat: copyMatrix(matrix), desc: `左乘更新矩阵` });

    const cols = [];
    for (let j = k; j < n; j++) cols.push(j);
    steps.push({ type: 'highlight_cols', cols, mat: copyMatrix(matrix), desc: `准备右乘` });

    householderRight(k);
    steps.push({ type: 'update', mat: copyMatrix(matrix), desc: `右乘更新矩阵` });
  }

  steps.push({ type: 'phase', phase: 'Hessenberg化完成', mat: copyMatrix(matrix), desc: 'Hessenberg化完成' });
}

let householderV = null;

function householderLeft(k) {
  let norm = 0;
  for (let i = k + 1; i < n; i++) norm += matrix[i][k] * matrix[i][k];
  norm = Math.sqrt(norm);
  if (norm < epsilon) { householderV = null; return; }

  householderV = new Array(n).fill(0);
  householderV[k + 1] = matrix[k + 1][k] + (matrix[k + 1][k] >= 0 ? norm : -norm);
  for (let i = k + 2; i < n; i++) householderV[i] = matrix[i][k];

  let vNorm = 0;
  for (let i = k + 1; i < n; i++) vNorm += householderV[i] * householderV[i];
  if (vNorm < epsilon) { householderV = null; return; }

  for (let i = k + 1; i < n; i++) householderV[i] /= Math.sqrt(vNorm);

  for (let j = k; j < n; j++) {
    let dot = 0;
    for (let i = k + 1; i < n; i++) dot += householderV[i] * matrix[i][j];
    for (let i = k + 1; i < n; i++) matrix[i][j] -= 2 * householderV[i] * dot;
  }
}

function householderRight(k) {
  if (!householderV) return;
  for (let i = 0; i < n; i++) {
    let dot = 0;
    for (let j = k + 1; j < n; j++) dot += matrix[i][j] * householderV[j];
    for (let j = k + 1; j < n; j++) matrix[i][j] -= 2 * dot * householderV[j];
  }
}

function applyGivensLeftByAngle(i, j, cosT, sinT) {
  givensCS = { i, j, c: cosT, s: sinT };
  for (let k = 0; k < n; k++) {
    const tmp1 = cosT * matrix[i][k] + sinT * matrix[j][k];
    const tmp2 = -sinT * matrix[i][k] + cosT * matrix[j][k];
    matrix[i][k] = tmp1;
    matrix[j][k] = tmp2;
  }
}

function applyGivensRightByAngle(i, j, cosT, sinT) {
  for (let k = 0; k < n; k++) {
    const tmp1 = cosT * matrix[k][i] + sinT * matrix[k][j];
    const tmp2 = -sinT * matrix[k][i] + cosT * matrix[k][j];
    matrix[k][i] = tmp1;
    matrix[k][j] = tmp2;
  }
}

function finalize2x2(start, end) {
  const a = matrix[start][start], b = matrix[start][end];
  const c = matrix[end][start], d = matrix[end][end];
  const tr = a + d, det = a * d - b * c;
  const disc = tr * tr - 4 * det;
  const ar = { start, end, shiftType: 'single' };

  if (disc >= 0) {
    const ev1 = (tr + Math.sqrt(disc)) / 2;
    const ev2 = (tr - Math.sqrt(disc)) / 2;
    const shift = Math.abs(d - ev1) < Math.abs(d - ev2) ? ev1 : ev2;

    steps.push({ type: 'phase', phase: '2×2块上三角化', mat: copyMatrix(matrix), desc: `上三角化 [${start+1}:${end+1}]`, activeRegion: ar });
    steps.push({ type: 'shift', shift, mat: copyMatrix(matrix), phase: '2×2块上三角化', desc: `精确位移 μ=${shift.toFixed(4)}`, activeRegion: ar });

    const x = matrix[start][start] - shift;
    const y = matrix[end][start];
    steps.push({ type: 'highlight_rows', rows: [start, end], mat: copyMatrix(matrix), desc: '准备Givens旋转', activeRegion: ar });
    applyGivensLeft(start, end, x, y);
    steps.push({ type: 'update', mat: copyMatrix(matrix), desc: '左乘Givens旋转', activeRegion: ar });
    steps.push({ type: 'highlight_cols', cols: [start, end], mat: copyMatrix(matrix), desc: '准备右乘', activeRegion: ar });
    applyGivensRight(start, end);
    steps.push({ type: 'update', mat: copyMatrix(matrix), desc: '右乘Givens旋转', activeRegion: ar });

    if (Math.abs(matrix[end][start]) < epsilon) matrix[end][start] = 0;
    steps.push({ type: 'phase', phase: '2×2块上三角化完成', mat: copyMatrix(matrix), desc: '次对角元已消去', activeRegion: ar });
    eigenvalues.push(matrix[start][start], matrix[end][end]);
  } else {
    const re = tr / 2, im = Math.sqrt(-disc) / 2;
    let cosT, sinT;
    const sumOffDiag = c + b;
    if (Math.abs(sumOffDiag) < epsilon && Math.abs(d - a) < epsilon) {
      cosT = 1; sinT = 0;
    } else {
      const theta2 = Math.atan2(d - a, sumOffDiag);
      cosT = Math.cos(theta2 / 2);
      sinT = Math.sin(theta2 / 2);
    }

    const arC = { start, end, shiftType: 'double' };
    steps.push({ type: 'phase', phase: '2×2块标准化', mat: copyMatrix(matrix), desc: `标准化为 [σ,β;γ,σ] [${start+1}:${end+1}]`, activeRegion: arC });
    steps.push({ type: 'highlight_rows', rows: [start, end], mat: copyMatrix(matrix), desc: '准备Givens旋转', activeRegion: arC });
    applyGivensLeftByAngle(start, end, cosT, sinT);
    steps.push({ type: 'update', mat: copyMatrix(matrix), desc: '左乘Givens旋转', activeRegion: arC });
    steps.push({ type: 'highlight_cols', cols: [start, end], mat: copyMatrix(matrix), desc: '准备右乘', activeRegion: arC });
    applyGivensRightByAngle(start, end, cosT, sinT);
    steps.push({ type: 'update', mat: copyMatrix(matrix), desc: '右乘Givens旋转', activeRegion: arC });

    steps.push({ type: 'phase', phase: '2×2块标准化完成', mat: copyMatrix(matrix), desc: `σ=${re.toFixed(4)}, βγ<0, 虚部=±${im.toFixed(4)}`, activeRegion: arC });
    eigenvalues.push({ re, im });
  }
}

function qrIterations(start, end, iter) {
  if (end - start <= 1) {
    if (end === start) {
      eigenvalues.push(matrix[start][start]);
    } else {
      finalize2x2(start, end);
    }
    return;
  }

  for (let k = start; k < end; k++) {
    if (Math.abs(matrix[k + 1][k]) <= epsilon * (Math.abs(matrix[k][k]) + Math.abs(matrix[k + 1][k + 1]))) {
      matrix[k + 1][k] = 0;
      steps.push({ type: 'deflation', row: k, mat: copyMatrix(matrix), desc: `收缩: 位置(${k+2},${k+1})置零` });
      qrIterations(k + 1, end, 0);
      qrIterations(start, k, 0);
      return;
    }
  }

  if (iter >= 30 * (end - start + 1)) {
    steps.push({ type: 'phase', phase: '达到迭代上限', mat: copyMatrix(matrix), desc: '停止迭代' });
    return;
  }

  const a = matrix[end - 1][end - 1], b = matrix[end - 1][end];
  const c = matrix[end][end - 1], d = matrix[end][end];
  const tr = a + d, det = a * d - b * c;
  const disc = tr * tr - 4 * det;

  globalIterCount++;
  const iterNum = globalIterCount;

  if (disc >= 0 || iter % 10 === 9) {
    let shift = d;
    if (disc >= 0) {
      const ev1 = (tr + Math.sqrt(disc)) / 2;
      const ev2 = (tr - Math.sqrt(disc)) / 2;
      shift = Math.abs(d - ev1) < Math.abs(d - ev2) ? ev1 : ev2;
    } else if (iter % 10 === 9) {
      shift = Math.abs(matrix[end][end - 1]) + (end > start + 1 ? Math.abs(matrix[end - 1][end - 2]) : 0);
    }

    steps.push({ type: 'shift', shift, mat: copyMatrix(matrix), phase: `第${iterNum}轮QR迭代 (单位移)`, desc: `单位移 μ=${shift.toFixed(4)}`, activeRegion: {start, end, shiftType: 'single'}, shiftBox: {start: end-1, end, isReal: true} });
    singleShiftQR(start, end, shift, iterNum);
  } else {
    steps.push({ type: 'shift', shift: { re: tr / 2, im: Math.sqrt(-disc) / 2 }, mat: copyMatrix(matrix), phase: `第${iterNum}轮QR迭代 (双位移)`, desc: `双位移 (复共轭对)`, activeRegion: {start, end, shiftType: 'double'}, shiftBox: {start: end-1, end, isReal: false} });
    doubleShiftQR(start, end, tr, det, iterNum);
  }

  qrIterations(start, end, iter + 1);
}

function singleShiftQR(start, end, shift, iterNum) {
  const ar = {start, end, shiftType: 'single'};
  steps.push({ type: 'phase', phase: `第${iterNum}轮QR迭代 (单位移)`, mat: copyMatrix(matrix), desc: '开始单位移隐式QR步 [2×2凸起]', activeRegion: ar });

  const x = matrix[start][start] - shift;
  const y = matrix[start + 1][start];

  steps.push({ type: 'highlight_rows', rows: [start, start + 1], mat: copyMatrix(matrix), desc: '凸起初始化 [2×2]', activeRegion: ar });
  applyGivensLeft(start, start + 1, x, y);
  steps.push({ type: 'update', mat: copyMatrix(matrix), desc: '左乘Givens旋转 [2×2]', activeRegion: ar });
  steps.push({ type: 'highlight_cols', cols: [start, start + 1], mat: copyMatrix(matrix), desc: '准备右乘 [2×2]', activeRegion: ar });
  applyGivensRight(start, start + 1);
  steps.push({ type: 'update', mat: copyMatrix(matrix), desc: '右乘Givens旋转 [2×2]', activeRegion: ar });

  for (let k = start; k < end - 1; k++) {
    const bulgeRow = k + 2;
    if (bulgeRow > end) break;

    steps.push({ type: 'highlight_rows', rows: [k + 1, bulgeRow], mat: copyMatrix(matrix), desc: `凸起追逐: 第${k-start+1}步 [2×2]`, activeRegion: ar });
    const x = matrix[k + 1][k];
    const y = matrix[bulgeRow][k];
    applyGivensLeft(k + 1, bulgeRow, x, y);
    steps.push({ type: 'update', mat: copyMatrix(matrix), desc: '左乘消去凸起 [2×2]', activeRegion: ar });
    steps.push({ type: 'highlight_cols', cols: [k + 1, bulgeRow], mat: copyMatrix(matrix), desc: '准备右乘 [2×2]', activeRegion: ar });
    applyGivensRight(k + 1, bulgeRow);
    steps.push({ type: 'update', mat: copyMatrix(matrix), desc: '右乘 [2×2]', activeRegion: ar });
  }

  steps.push({ type: 'phase', phase: '单位移QR步完成', mat: copyMatrix(matrix), desc: '凸起已消除 [2×2]', activeRegion: ar });
}

function doubleShiftQR(start, end, s, t, iterNum) {
  if (end - start < 2) return;

  const ar = {start, end, shiftType: 'double'};
  steps.push({ type: 'phase', phase: `第${iterNum}轮QR迭代 (双位移)`, mat: copyMatrix(matrix), desc: '开始双位移隐式QR步 [3×3凸起]', activeRegion: ar });

  const h11 = matrix[start][start], h12 = matrix[start][start + 1];
  const h21 = matrix[start + 1][start], h22 = matrix[start + 1][start + 1];
  const h32 = start + 2 <= end ? matrix[start + 2][start + 1] : 0;

  const p = h11 * h11 + h12 * h21 - s * h11 + t;
  const q = h21 * (h11 + h22 - s);
  const r = h21 * h32;

  steps.push({ type: 'highlight_rows', rows: [start, start + 1, start + 2], mat: copyMatrix(matrix), desc: '3×3凸起初始化', activeRegion: ar });
  applyHouseholder3Left(start, p, q, r);
  steps.push({ type: 'update', mat: copyMatrix(matrix), desc: '左乘Householder变换 [3×3]', activeRegion: ar });
  steps.push({ type: 'highlight_cols', cols: [start, start + 1, start + 2], mat: copyMatrix(matrix), desc: '准备右乘 [3×3]', activeRegion: ar });
  applyHouseholder3Right(start);
  steps.push({ type: 'update', mat: copyMatrix(matrix), desc: '右乘Householder变换 [3×3]', activeRegion: ar });

  for (let k = start; k < end - 2; k++) {
    const rows = [k + 1, k + 2, k + 3];
    steps.push({ type: 'highlight_rows', rows, mat: copyMatrix(matrix), desc: `凸起追逐: 第${k-start+1}步 [3×3]`, activeRegion: ar });
    const p = matrix[k + 1][k];
    const q = matrix[k + 2][k];
    const r = matrix[k + 3][k];
    applyHouseholder3Left(k + 1, p, q, r);
    steps.push({ type: 'update', mat: copyMatrix(matrix), desc: '左乘消去凸起 [3×3]', activeRegion: ar });
    steps.push({ type: 'highlight_cols', cols: rows, mat: copyMatrix(matrix), desc: '准备右乘 [3×3]', activeRegion: ar });
    applyHouseholder3Right(k + 1);
    steps.push({ type: 'update', mat: copyMatrix(matrix), desc: '右乘 [3×3]', activeRegion: ar });
  }

  if (end - start >= 2) {
    steps.push({ type: 'highlight_rows', rows: [end - 1, end], mat: copyMatrix(matrix), desc: '最后一步: 2×2凸起', activeRegion: ar });
    const x = matrix[end - 1][end - 2];
    const y = matrix[end][end - 2];
    applyGivensLeft(end - 1, end, x, y);
    steps.push({ type: 'update', mat: copyMatrix(matrix), desc: '左乘消去残余凸起 [2×2]', activeRegion: ar });
    steps.push({ type: 'highlight_cols', cols: [end - 1, end], mat: copyMatrix(matrix), desc: '准备右乘 [2×2]', activeRegion: ar });
    applyGivensRight(end - 1, end);
    steps.push({ type: 'update', mat: copyMatrix(matrix), desc: '右乘 [2×2]', activeRegion: ar });
  }

  steps.push({ type: 'phase', phase: '双位移QR步完成', mat: copyMatrix(matrix), desc: '凸起已消除 [3×3→2×2]', activeRegion: ar });
}

let givensCS = null;

function applyGivensLeft(i, j, x, y) {
  const r = Math.sqrt(x * x + y * y);
  if (r < epsilon) { givensCS = null; return; }
  const c = x / r, s = y / r;
  givensCS = { i, j, c, s };

  for (let k = 0; k < n; k++) {
    const tmp1 = c * matrix[i][k] + s * matrix[j][k];
    const tmp2 = -s * matrix[i][k] + c * matrix[j][k];
    matrix[i][k] = tmp1;
    matrix[j][k] = tmp2;
  }
}

function applyGivensRight(i, j) {
  if (!givensCS) return;
  const { c, s } = givensCS;
  for (let k = 0; k < n; k++) {
    const tmp1 = c * matrix[k][i] + s * matrix[k][j];
    const tmp2 = -s * matrix[k][i] + c * matrix[k][j];
    matrix[k][i] = tmp1;
    matrix[k][j] = tmp2;
  }
}

let householder3V = null;
let householder3Start = 0;

function applyHouseholder3Left(start, p, q, r) {
  const norm = Math.sqrt(p * p + q * q + r * r);
  if (norm < epsilon) { householder3V = null; return; }

  householder3V = [p + (p >= 0 ? norm : -norm), q, r];
  const vNorm = Math.sqrt(householder3V[0] ** 2 + householder3V[1] ** 2 + householder3V[2] ** 2);
  if (vNorm < epsilon) { householder3V = null; return; }

  householder3V[0] /= vNorm; householder3V[1] /= vNorm; householder3V[2] /= vNorm;
  householder3Start = start;

  for (let j = 0; j < n; j++) {
    const dot = householder3V[0] * matrix[start][j] + householder3V[1] * matrix[start + 1][j] + householder3V[2] * matrix[start + 2][j];
    matrix[start][j] -= 2 * householder3V[0] * dot;
    matrix[start + 1][j] -= 2 * householder3V[1] * dot;
    matrix[start + 2][j] -= 2 * householder3V[2] * dot;
  }
}

function applyHouseholder3Right(start) {
  if (!householder3V) return;
  for (let i = 0; i < n; i++) {
    const dot = householder3V[0] * matrix[i][start] + householder3V[1] * matrix[i][start + 1] + householder3V[2] * matrix[i][start + 2];
    matrix[i][start] -= 2 * dot * householder3V[0];
    matrix[i][start + 1] -= 2 * dot * householder3V[1];
    matrix[i][start + 2] -= 2 * dot * householder3V[2];
  }
}

function displayCurrentStep() {
  if (currentStep >= steps.length) {
    document.getElementById('currentPhase').textContent = '算法完成';
    document.getElementById('currentOp').textContent = '所有特征值已收敛';
    displayMatrix(matrix, [], [], null, null);
    return;
  }

  const step = steps[currentStep];
  const phase = step.phase || document.getElementById('currentPhase').textContent;
  document.getElementById('currentPhase').textContent = phase;
  document.getElementById('currentOp').textContent = step.desc;

  const rows = step.rows || [];
  const cols = step.cols || [];
  displayMatrix(step.mat, rows, cols, step.activeRegion || null, step.shiftBox || null);

}

function getStepSize() {
  const val = document.getElementById('stepSize').value;
  return val === 'phase' ? 'phase' : parseInt(val);
}

function isHighlightStep(step) {
  return step.type === 'highlight_rows' || step.type === 'highlight_cols';
}

function isInfoStep(step) {
  return step.type === 'phase' || step.type === 'shift' || step.type === 'deflation' || step.type === 'direct';
}

function nextStep() {
  const stepSize = getStepSize();
  if (stepSize === 'phase') {
    do {
      currentStep++;
    } while (currentStep < steps.length && (steps[currentStep].type !== 'phase' || isHighlightStep(steps[currentStep])));
  } else if (stepSize === 2) {
    let updateCount = 0;
    while (currentStep < steps.length) {
      currentStep++;
      if (currentStep >= steps.length) break;
      const s = steps[currentStep];
      if (isHighlightStep(s)) continue;
      if (isInfoStep(s)) break;
      if (s.type === 'update') { updateCount++; if (updateCount >= 2) break; }
    }
  } else {
    currentStep = Math.min(currentStep + stepSize, steps.length);
  }

  document.getElementById('stepCounter').textContent = `${currentStep} / ${steps.length}`;
  document.getElementById('prevBtn').disabled = currentStep === 0;
  updateProgress();
  displayCurrentStep();

  if (currentStep >= steps.length) {
    document.getElementById('stepBtn').disabled = true;
    if (isPlaying) togglePlay();
  }
}

function prevStep() {
  const stepSize = getStepSize();
  if (stepSize === 'phase') {
    do {
      currentStep--;
    } while (currentStep > 0 && (steps[currentStep].type !== 'phase' || isHighlightStep(steps[currentStep])));
  } else if (stepSize === 2) {
    let updateCount = 0;
    while (currentStep > 0) {
      currentStep--;
      const s = steps[currentStep];
      if (isHighlightStep(s)) continue;
      if (isInfoStep(s)) break;
      if (s.type === 'update') { updateCount++; if (updateCount >= 2) break; }
    }
  } else {
    currentStep = Math.max(currentStep - stepSize, 0);
  }

  document.getElementById('stepCounter').textContent = `${currentStep} / ${steps.length}`;
  document.getElementById('stepBtn').disabled = false;
  document.getElementById('prevBtn').disabled = currentStep === 0;
  updateProgress();
  displayCurrentStep();
}

function togglePlay() {
  isPlaying = !isPlaying;
  document.getElementById('playBtn').textContent = isPlaying ? '⏸ 暂停' : '▶ 播放';

  if (isPlaying) {
    const speed = parseInt(document.getElementById('speedSlider').value);
    playInterval = setInterval(() => {
      if (currentStep >= steps.length) {
        togglePlay();
      } else {
        nextStep();
      }
    }, speed);
  } else {
    clearInterval(playInterval);
  }
}

function updateProgress() {
  const percent = steps.length > 0 ? (currentStep / steps.length) * 100 : 0;
  document.getElementById('progressFill').style.width = percent + '%';
}

function jumpToProgress(event) {
  if (steps.length === 0) return;
  const bar = event.currentTarget;
  const rect = bar.getBoundingClientRect();
  const x = event.clientX - rect.left;
  const percent = x / rect.width;
  currentStep = Math.round(percent * steps.length);
  currentStep = Math.max(0, Math.min(currentStep, steps.length));

  document.getElementById('stepCounter').textContent = `${currentStep} / ${steps.length}`;
  document.getElementById('stepBtn').disabled = currentStep >= steps.length;
  document.getElementById('prevBtn').disabled = currentStep === 0;
  updateProgress();
  displayCurrentStep();
}

function reset() {
  if (isPlaying) togglePlay();
  currentStep = 0;
  eigenvalues = [];
  globalIterCount = 0;
  document.getElementById('startBtn').disabled = false;
  document.getElementById('stepBtn').disabled = true;
  document.getElementById('playBtn').disabled = true;
  document.getElementById('prevBtn').disabled = true;
  document.getElementById('currentPhase').textContent = '未开始';
  document.getElementById('currentOp').textContent = '-';
  document.getElementById('stepCounter').textContent = '0 / 0';
  document.getElementById('matrixDisplay').innerHTML = '';
  updateProgress();
}

createMatrixInput();
</script>
</body>
</html>